{
  "name": "nanotimer",
  "main": "./lib/nanoTimer.js",
  "description": "A much higher accuracy timer object that makes use of the node.js hrtime function call.",
  "version": "0.3.10",
  "authors": [
    "Kevin Briggs <krb686@gmail.com> (https://github.com/Krb686)"
  ],
  "keywords": [
    "timer",
    "nanotimer",
    "nano",
    "nanoseconds",
    "micro",
    "microseconds",
    "stopwatch"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/Krb686/nanotimer.git"
  },
  "readme": "# nanoTimer\r\n# Current Version - 0.3.10\r\n\r\n![](https://api.travis-ci.org/Krb686/nanoTimer.png)\r\n\r\n[![NPM](https://nodei.co/npm/nanotimer.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/nanotimer/)\r\n\r\nA much higher accuracy timer object that makes use of the node.js [hrtime](http://nodejs.org/api/process.html#process_process_hrtime) function call.\r\n\r\nThe nanotimer recreates the internal javascript timing functions with higher resolution.\r\n\r\n##Note\r\n\r\n- 1) With the normal timing functions, instead of dealing with the obscurities of multiple setTimeout and \r\nsetInterval calls, now there is a concrete timer object, each of which can handle exactly 1 timeOut and \r\nsetInterval task. This also means a reference is not needed to clear an interval since each timer object is\r\nunique.\r\n\r\n- 2) Timer objects use the non-blocking feature **setImmediate** for time counting and synchronization. This requires node v0.10.13 or greater\r\n\r\n- 3) Errors in timing are also non-cumulative.  For example, when using the setInterval command, the timer counts\r\nand compares the time difference since starting against the interval length specified and if it has run past the interval, \r\nit resets.  If the code had an error of 1 millisecond delay, the timer would actually count to 1001 milliseconds before resetting, and that\r\n1 millisecond error would propagate through each cycle and add up very quickly!  To solve that problem, rather than resetting\r\nthe interval variable each cycle, it is instead incremented with each cycle count.  So on the 2nd cycle, it compares to 2000 milliseconds, \r\nand it may run to 2001.  Then 3000 milliseconds, running to 3001, and so on.  This is only limited by the comparison variable potentially overflowing, so I \r\nsomewhat arbitrarily chose a value of 8 quadrillion (max is roughly 9 quadrillion in javascript) before it resets.  Even using nanosecond resolution however, \r\nthe comparison variable would reach 8 quadrillion every 8 million seconds, or every 93.6ish days.\r\n\r\n##Usage\r\n\r\n```js\r\n\r\nvar NanoTimer = require('nanotimer');\r\n\r\nvar timerA = new NanoTimer();\r\n\r\n\r\n```\r\n\r\nEach NanoTimer object can run other functions that are already defined.  This can be done in 2 ways, either with a literal function object, or with a function declaration.\r\n\r\n### By function object\r\n```js\r\nvar NanoTimer = require('nanotimer');\r\nvar timerObject = new NanoTimer();\r\n\r\n\r\nvar countToOneBillion = function () {\r\n    var i = 0;\r\n    while(i < 1000000000){\r\n        i++;\r\n    }\r\n};\r\n\r\nvar microsecs = timerObject.time(countToOneBillion, 'u');\r\nconsole.log(microsecs);\r\n```\r\n\r\nor something like this:\r\n\r\n### by function declaration\r\n\r\n```js\r\nvar NanoTimer = require('nanotimer');\r\n\r\nfunction main(){\r\n    var timerObject = new NanoTimer();\r\n    \r\n    var microsecs = timerObject.time(countToOneBillion, 'u');\r\n    console.log(microsecs);\r\n}\r\n\r\nfunction countToOneBillion(){\r\n    var i = 0;\r\n    while(i < 1000000000){\r\n        i++;\r\n    }\r\n}\r\n\r\nmain();\r\n```\r\n  \r\n##Full example\r\n\r\n```js\r\nvar NanoTimer = require('nanotimer');\r\n\r\nvar count = 10;\r\n\r\n\r\nfunction main(){\r\n    var timer = new NanoTimer();\r\n    \r\n    timer.setInterval(countDown, '', '1s');\r\n    timer.setTimeout(liftOff, [timer], '10s');\r\n    \r\n\r\n\r\n}\r\n\r\nfunction countDown(){\r\n    console.log('T - ' + count);\r\n    count--;\r\n}\r\n\r\nfunction liftOff(timer){\r\n    timer.clearInterval();\r\n    console.log('And we have liftoff!');\r\n}\r\n\r\nmain();\r\n```\r\n\r\n### In the above example, the interval can also be cleared another way rather than having to pass in the timer object to the liftOff task.\r\nInstead, it can be done by specifying a callback to setTimeout, since the timer object will exist in that scope.  Like so:\r\n\r\n```js\r\ntimer.setTimeout(liftOff, '', '10s', function(){\r\n    timer.clearInterval();\r\n});\r\n```\r\n\r\n\r\n## .setTimeout(task, args, timeout, [callback])\r\n* Calls function 'task' with argument(s) 'args' after specified amount of time, 'timeout'.\r\n* timeout, specified as a number plus a letter concatenated into a string. ex - '200u', '150n', '35m', '10s'.\r\n* callback is optional.  If it is specified, it is called when setTimeout runs it's assigned task, and it is sent a parameter that\r\ntells the actual amount of time that passed before the specifed task was run, in nanoseconds.\r\n\r\n```js\r\nconsole.log(\"It's gonna be legen-wait for it...\");\r\n\r\ntimerA.setTimeout(dary, '', '2s');\r\n\r\nfunction dary(){\r\n    console.log(\"dary!!\");\r\n}\r\n```\r\n\r\n## .setInterval(task, args, interval, [callback])\r\n* Repeatedly calls function 'task' with arguments 'args' after every interval amount of time. If interval is specified as 0, it will run as fast as possible!\r\n* This function is self correcting, error does not propagate through each cycle, as described above.\r\n* interval, specified as a number plus a letter concatenated into a string. ex - '200u', '150n', '35m', '10s'.\r\n* callback is optional, and is only called once the interval is cleared.\r\n\r\n```js\r\ntimerA.setInterval(task, '100m', function(err) {\r\n    if(err) {\r\n        //error\r\n    }\r\n});\r\n```\r\n\r\n## .time(task, args, format, [callback])\r\n* Returns the amount of time taken to run function 'task', called with arguments 'args'.\r\n* format specifies the units time will be returned in. Options are 's' for seconds, 'm' for milliseconds, 'u' for microseconds, \r\nand 'n' for nanoseconds. if no format is specified, returns the default array of [s, n] where s is seconds and n is nanoseconds.\r\n* callback is optional\r\n\r\n### Synchronous Example:\r\n```js\r\n\r\nvar runtimeSeconds = timerA.time(doMath, 'u');\r\n\r\nfunction doMath(){\r\n    //do math\r\n}\r\n\r\n```\r\n\r\n### Asynchronous Use: (yes, it can time asynchronous stuff! here's how)\r\n\r\nIn order to time something asynchronous, it's no surprise that the timer object must somehow be notified whenever that asynchronous task finishes.\r\nTo do that, you must have your function to be timed accept a callback as a parameter, and manually call that callback (to the timer function) inside of the asynchronous task's\r\ncallback. It's essentially a chain of callbacks, which is probably already familiar to you. Here's an example that times how long it takes to read a file.\r\nSuppose you're using node.js's fs.ReadFile, which is asynchronous, then create a wrapper like so: \r\n```js\r\nvar NanoTimer = require('nanotimer');\r\nvar fs = require('fs');\r\n\r\nvar timer = new NanoTimer();\r\n\r\n\r\ntimer.time(loadFile, '', 'u', function(time){\r\n    console.log(\"It took \" + time + \" microseconds to read that file!\");\r\n});\r\n\r\nfunction loadFile(callback){\r\n    fs.readFile('testReadFile.js', function(err, data){\r\n        if(err) throw err;\r\n        console.log(data);\r\n        \r\n        callback();\r\n    });\r\n}\r\n```\r\n\r\nOnce again, just two changes from normal.  First, your function to be timed, in this case 'loadFile' (which is just a proxy function to perfom fs.readFile) must\r\naccept a callback parameter.  Second, in the callback of whatever asynchronous task is being performed inside the proxy, the callback passed in must be called after everything\r\nis finished. That callback that you call manually immediately takes the 2nd reference time, and then calls your callback specified in timer.time, ending the process.\r\n\r\n## .clearInterval()\r\n* Clears current running interval\r\n```js\r\ntimer.clearInterval();\r\n```\r\n\r\n## .clearTimeout()\r\n* Clears current running timeOut\r\n```js\r\ntimer.clearTimeout();\r\n```\r\n\r\n#Logging\r\n* Added preliminary logging feature.  If a timer is created by passing in 'log', it will enable verbose logging from the timer, so you can\r\nfigure out the real amount of time being taken for setTimeout or setInterval\r\n* Currently only works on setInterval, and displays the 'cycle time', or real interval time to demonstrate how error does not propagate.  This will \r\nbe further expanded on.\r\n\r\n# Tests\r\n\r\n* Test suite used is mocha.\r\n* Tests also require **should**\r\n* In order for the test to perform properly, the timeout must be altered.\r\n* I prefer running tests with `mocha -R spec -t 10000`\r\n\r\n![](https://raw.github.com/Krb686/nanotimer/master/test/nanotimer_0_2_6_test_partial.png \"Test Results\")\r\n\r\n# Performance\r\n\r\nVersion 0.3.1 brings about a potentially massive performance boost over previous versions.\r\n\r\nPrevious versions used a setImmediate loop running as fast as possible for checking when to execute, inside setTimeout and setInterval.\r\nIn 0.3.1, this has changed when using an intervalTime (setInterval), or delayTime (setTimeout) that is longer than 25ms.  Execution will be deferred to the standard\r\njavascript setTimeout, aimed for 25ms before scheduled execution, where the setImmediate loop will resume.\r\n\r\nThe assumed error of javascript's setTimeout is 25ms.\r\n\r\nBelow is a test case with setInterval set to 1 second.\r\n\r\n![](https://raw.github.com/Krb686/nanotimer/master/test/nanotimer_non_deferred.png \"Non-Deferred\")\r\n\r\n![](https://raw.github.com/Krb686/nanotimer/master/test/nanotimer_deferred.png \"Deferred\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Krb686/nanotimer/issues"
  },
  "homepage": "https://github.com/Krb686/nanotimer",
  "_id": "nanotimer@0.3.10",
  "_from": "nanotimer@0.3.10"
}
