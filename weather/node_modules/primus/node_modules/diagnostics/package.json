{
  "name": "diagnostics",
  "version": "1.0.1",
  "description": "Tools for debugging your node.js modules and event loop",
  "main": "index.js",
  "browser": "./browser.js",
  "scripts": {
    "test": "mocha --reporter spec --ui bdd test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/bigpipe/diagnostics.git"
  },
  "keywords": [
    "debug",
    "debugger",
    "debugging",
    "diagnostic",
    "diagnostics",
    "event",
    "loop",
    "metrics",
    "stats"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/bigpipe/diagnostics/issues"
  },
  "homepage": "https://github.com/bigpipe/diagnostics",
  "devDependencies": {
    "assume": "1.2.x",
    "mocha": "2.2.x",
    "pre-commit": "1.0.x"
  },
  "dependencies": {
    "colorspace": "1.0.x",
    "enabled": "1.0.x",
    "kuler": "0.0.x"
  },
  "readme": "# Diagnostics\n\n[![Build Status](https://travis-ci.org/bigpipe/diagnostics.svg?branch=master)](https://travis-ci.org/bigpipe/diagnostics)\n\nDiagnostics is a small debugging library which allows you to output your debug\nlogs by setting an environment variable. The library works for server-side and\nclient-size applications so it's great for writing isomorphic JavaScript.\n\nThe debug output can be triggered using environment variables on the server and\nusing localStorage, hashtags and window.name on the browser. If the debug output\nis not enabled this module will result in an empty function causing the\nJavaScript compiler engines to remove it completely from your code so there is\nabsolutely no performance overhead or excuses left to not use logging in your\ncode!\n\n## Installation\n\nThe module is released in the public npm registry and can easily be installed by\nrunning.\n\n```\nnpm install --save diagnostics\n```\n\nFor client-side/front-end facing application we assume that you're using\n`browserify` as your build tool as the client code is bundled as the\n`browser.js` file in the root of this repository.\n\n## Usage\n\nWhen you require the module it returns a function that expect a name or prefix\nfor the debug messages. This prefix is what you use to enable specific debug\nmessages.\n\nThe exported function of the module accepts 2 arguments:\n\n1. `name` The namespace of the debug logger.\n2. `options` These options can only be applied to the server, not client code:\n  - `colors`: Enable or disable colors. Defaults to true if your stdout is a tty.\n  - `stream`: The stream instance we should write our logs to. We default to\n    `process.stdout` (unless you change the default using the `.to` method).\n\n```js\nvar debug = require('diagnostics')('foo');\ndebug('hello world %d', 12);\n```\n\nIn the example above you can see that we've created a new diagnostics function\ncalled debug. It's name is set to `foo`. So when we run this in Node.js using:\n\n```\nnode index.js\n```\n\nWe will see nothing in the console as the log messages are disabled by default.\nBut when set the `DEBUG` or `DIAGNOSTICS` environment variables to the name of\nthe debug function it will show up:\n\n```\nDIAGNOSTICS=foo node index.js\n\nhello world 12\n```\n\nYou can enable or disable specific diagnostic instances in the ENV variables by\nseparating them using a space or comma:\n\n```\nDEBUG=foo,-bar,primus:*\n```\n\nIn the example above you also see an example of a wild card `*`. This ensures\nthat anything after it or before it will be allowed.\n\nTo make it easier to see where the log messages are coming from they are\ncolored automatically based on the namespace you provide them. The deeper the\nnamespace, the lighter name will be toned as seen in the following output.\n\n![output](output.PNG)\n\n## Browser\n\nThe usage for browser is exactly the same as for node. You require the\n`diagnostics` method and supply it with a name argument. The big difference is\nthat no longer can use environment variables as these only work on the server.\nSo to go around that you can use:\n\n- **hashtag** The hashtag will be parsed using query string decoding. So if you\n  have an hash `#debug=foo` it will trigger all `foo` lines to be dumped to your\n  browser console.\n- **localStorage** We will search for a query string in either the `env` or\n  `debug` key of `localStorage`. We again assume that the value has query string\n  encode value which contains either `debug` or `diagnostics`.\n  `localStorage.env = 'diagnostics=foo'`.\n- **window.name** As `localStorage` is not available in all browsers, we provide\n  a fallback to `window.name` which can contain the same values as the\n  `localStorage`'s env/debug keys.\n\nUnlike the server, the output of the browser is not colored. The reason for this\nthat it would take a considerable amount of code. Which is not worth the benefit\nas you usually want your front-end code to be as small as possible.\n\n#### Multiple streams\n\n> Please note that this feature is server-side only as in the browser we can only\n> output to the console\n\nThe beauty of this logger is that it allows a custom stream where you can write\nthe data to. So you can just log it all to a separate server, database and what\nnot. But we don't just allow one stream we allow multiple streams so you might\nwant to log to disk AND just output it in your terminal. The only thing you need\nto do is either use:\n\n```js\nrequire('diagnostics').to([\n  stream1,\n  stream2\n]);\n```\n\nTo set multiple streams as the default streams or supply an array for the logger\nit self:\n\n```js\nvar debug = require('diagnostics')('example', { stream: [\n  stream1,\n  stream2\n]});\n\ndebug('foo');\n```\n\n## License\n\n[MIT](LICENSE.md)\n",
  "readmeFilename": "README.md",
  "_id": "diagnostics@1.0.1",
  "_from": "diagnostics@1.0.x"
}
