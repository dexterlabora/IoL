{
  "name": "recovery",
  "version": "0.2.6",
  "description": "Recover from a network failure using randomized exponential backoff",
  "main": "index.js",
  "scripts": {
    "100%": "istanbul check-coverage --statements 100 --functions 100 --lines 100 --branches 100",
    "test": "mocha test.js",
    "watch": "mocha --watch test.js",
    "coverage": "istanbul cover _mocha -- test.js",
    "test-travis": "istanbul cover _mocha --report lcovonly -- test.js"
  },
  "keywords": [
    "random",
    "exponential",
    "backoff",
    "reconnect",
    "retry",
    "recovery",
    "failure",
    "network",
    "recon",
    "connection",
    "connect",
    "disconnect"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "devDependencies": {
    "assume": "1.2.x",
    "istanbul": "0.3.x",
    "mocha": "2.2.x",
    "pre-commit": "1.1.x"
  },
  "dependencies": {
    "demolish": "1.0.x",
    "eventemitter3": "1.1.x",
    "millisecond": "0.1.x",
    "one-time": "0.0.x",
    "tick-tock": "1.0.x"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/unshiftio/recovery"
  },
  "pre-commit": [
    "coverage",
    "100%"
  ],
  "readme": "# Recovery\n\n[![Made by unshift][made-by]](http://unshift.io)[![Version npm][version]](http://browsenpm.org/package/recovery)[![Build Status][build]](https://travis-ci.org/unshiftio/recovery)[![Dependencies][david]](https://david-dm.org/unshiftio/recovery)[![Coverage Status][cover]](https://coveralls.io/r/unshiftio/recovery?branch=master)[![IRC channel][irc]](http://webchat.freenode.net/?channels=unshift)\n\n[made-by]: https://img.shields.io/badge/made%20by-unshift-00ffcc.svg?style=flat-square\n[version]: https://img.shields.io/npm/v/recovery.svg?style=flat-square\n[build]: https://img.shields.io/travis/unshiftio/recovery/master.svg?style=flat-square\n[david]: https://img.shields.io/david/unshiftio/recovery.svg?style=flat-square\n[cover]: https://img.shields.io/coveralls/unshiftio/recovery/master.svg?style=flat-square\n[irc]: https://img.shields.io/badge/IRC-irc.freenode.net%23unshift-00a8ff.svg?style=flat-square\n\nRecovery provides randomized exponential back off for reconnection attempts. It\nallows you to recover the connection in the most optimal way (for both server\nand client). The exponential back off is randomized to prevent a DDOS like\nattack on your server when it's restarted, spreading the reconnection attempts\ninstead of having all your connections attempt to reconnect at exactly the same\ntime.\n\n### Features\n\n- Reconnection and progress events.\n- Randomized exponential back off.\n- Reconnection timeouts.\n- Browserify compatible.\n\nThe code base of this module was originally written for [Primus] but has been\nextracted as separate module. It has been thoroughly tested and it's written\nwith love `<3`\n\n## Installation\n\nAs this module can be used with node.js and browserify it's released in the `npm`\nregistry and can be installed using:\n\n```\nnpm install --save recovery\n```\n\n## Events\n\nAs mentioned in the documentation introduction, this library provides various of\nreconnection and progress events. Events **always** receive a \"status\" or\nprogress object as last argument. This object contains useful information about\ncurrent reconnection progress:\n\n- `attempt`:  Which reconnection attempt are we currently processing.\n- `start`: Starting time of reconnection attempt.\n- `duration`: How long have we taken so far to establish the connection.\n- `scheduled`: In how many ms do we schedule the next reconnection attempt.\n\nIn addition to these values it also contains all the configuration options like\n`retries`, `min`, `max` etc.\n\nThe following events are emitted during the recovery process:\n\nEvent                 | Arguments   | Description\n----------------------|-------------|-----------------------------------------------------\n`reconnect scheduled` | status      | Scheduled a new reconnection attempt.\n`reconnect`           | status, fn  | It's time for you to reconnect to the server.\n`reconnected`         | status      | Successfully reconnected.\n`reconnect failed`    | err, status | Failed to reconnect and ran out of attempts.\n`reconnect timeout`   | err, status | Failed to reconnect in a timely manner, will retry.\n\n## Constructing\n\nIn all code examples we assume that you've loaded the library using:\n\n```js\n'use strict';\n\nvar Recovery = require('recovery');\n```\n\nThe module is exported as a constructor. The constructor accepts an optional\noptions object which allows you to configure the reconnection procedure.\nThe following options are accepted:\n\n- `max` Maximum reconnection delay. Defaults to `Infinity`.\n- `min` Minimum reconnection delay. Defaults to `500 ms`.\n- `retries` Maximum amount retries after this we will emit an `reconnect failed`\n  event. Defaults to `10`.\n- `reconnect timeout` Time you have to reconnect to the server. If it takes\n  longer than the specified value we will emit an `reconnect timeout` event and\n  schedule another reconnection attempt. Defaults to `30 seconds`.\n- `factor` Exponential back off factor. Defaults to `2`.\n\nOptions that indicate a time can either be set using a human readable string\nlike `10 seconds`, `1 day`, `10 ms` etc. or a numeric value which represents the\ntime in milliseconds.\n\n```js\nvar recovery = new Recovery({\n  max: '30 seconds',\n  min: '100 milliseconds',\n  retries: 5\n});\n```\n\n### Reconnecting\n\nBefore every reconnection attempt we emit a `reconnect` event. You can listen\nto this event on your assigned event emitter. After the event is emitted\nwe will start a timeout so your attempts have only a limited amount of time to\nsucceed or fail. If the timeout expires we emit a `reconnect timeout` event and\nstart a whole new reconnection procedure.\n\nIf your reconnection attempt is successful call the `reconnect.reconnected()`\nmethod without any arguments. If it failed you can call the method with an error\nargument. If the operation failed we will automatically schedule a new reconnect\nattempt. When it's successful we will do some small internal clean up and emit\nthe `reconnected` event. If all future attempts fail we will eventually emit the\n`reconnect failed` event which basically indicates that something horrible is\ngoing on.\n\n```js\nrecovery = new Recovery();\n\nrecovery.on('reconnect', function (opts) {\n  console.log(opts.attempt);\n\n  reconnectmyconnection(function (err) {\n    if (err) return reconnect.reconnected(err);\n    reconnect.reconnected();\n  });\n});\n\nrecovery.reconnect();\n```\n\nAlternatively you also call the callback which is provided in the `reconnect`\nevent which is the same as the `reconnected` method.\n\n```js\nrecovery.on('reconnect', function (opts, fn) {\n  reconnectmyconnection(fn);\n});\n```\n\nTo check if a reconnection attempt is already running you can call the\n`reconnecting` method which will return a boolean:\n\n```js\nif (!recovery.reconnecting()) recovery.reconnect();\n```\n\nAnd if you wish to cancel the running reconnection attempt you can call the\n`reset` method:\n\n```js\nif (recovery.reconnecting()) recovery.reset();\n```\n\n## License\n\nMIT\n\n[Primus]: http://primus.io\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/unshiftio/recovery/issues"
  },
  "homepage": "https://github.com/unshiftio/recovery",
  "_id": "recovery@0.2.6",
  "_from": "recovery@0.2.x"
}
